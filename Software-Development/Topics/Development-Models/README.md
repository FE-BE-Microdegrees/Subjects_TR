# Software Development Models

- [Software Development Models](#software-development-models)
  - [Learning Outcomes](#learning-outcomes)
  - [What are Software Development Models?](#what-are-software-development-models)
    - [**Waterfall Model:**](#waterfall-model)
    - [**Lean:**](#lean)
    - [**Spiral Model:**](#spiral-model)
    - [**Agile Model:**](#agile-model)
    - [**Feature-Driven Development (FDD):**](#feature-driven-development-fdd)
    - [**Extreme Programming (XP):**](#extreme-programming-xp)
    - [**Kanban:**](#kanban)
    - [**Scrum:**](#scrum)

## Learning Outcomes

After completing this topic, you will be able to:

- Understand the nature of software development models;
- Identify common software development models;
- Describe the advantages and disadvantages of software development models;

## What are Software Development Models?

Software development models are structured approaches to software development that define the stages and processes to be followed during software production. These models can be linear, sequential, or iterative, depending on the nature and requirements of the project. Here are some common software development models:

### **Waterfall Model:**

- **Description:** A linear and sequential approach where each phase must be completed before the next one begins. It is the earliest SDLC approach.
- **Advantages:** Clear structure, easy to understand, well-defined stages.
- **Disadvantages:** Difficult to make changes after a phase is completed, not suitable for complex projects.

### **Lean:**

- **Description:** Originated from manufacturing, focuses on optimizing resources and delivering customer value. The goal is to eliminate any "waste" from the process.
- **Advantages:** Efficient use of resources, focuses on delivering value.
- **Disadvantages:** May overlook necessary tasks as "waste," requires a deep understanding for proper implementation.

### **Spiral Model:**

- **Description:** Combines the design phase of the waterfall model with the iterative philosophy of prototyping. Focuses on risk assessment at every spiral.
- **Advantages:** Emphasizes risk management, flexibility in design and requirements.
- **Disadvantages:** Can be expensive, requires expertise in risk assessment.

### **Agile Model:**

- **Description:** An iterative approach to software delivery that builds software incrementally, focusing on customer feedback and rapid iterations.
- **Advantages:** Flexible, promotes iterative feedback, encourages customer involvement.
- **Disadvantages:** Less predictable, can be difficult for those used to traditional methods.

### **Feature-Driven Development (FDD):**

- **Description:** An iterative and incremental software development process driven by a list of features.
- **Advantages:** Focuses on creating and delivering specific, client-valued features.
- **Disadvantages:** Not as flexible as other agile methodologies, requires detailed documentation.

### **Extreme Programming (XP):**

- **Description:** An agile framework that emphasizes customer satisfaction by delivering frequent "releases" in short development cycles to improve productivity and introduce checkpoints.
- **Advantages:** Emphasizes code quality, encourages customer involvement.
- **Disadvantages:** Requires extensive customer involvement, can be intense for developers.

### **Kanban:**

- **Description:** A visual process management approach that takes cues from lean manufacturing and emphasizes just-in-time delivery.
- **Advantages:** Flexibility, continuous delivery, visual nature helps identify bottlenecks.
- **Disadvantages:** Less structured, can lead to overloading if not properly managed.

### **Scrum:**

- **Description:** A type of agile methodology that organizes work into cycles called "Sprints," typically lasting 2-4 weeks.
- **Advantages:** Regular product deliveries, transparency, adaptability.
- **Disadvantages:** Requires experienced team members, scope can sometimes be too flexible.

In summary, the choice of SDLC framework depends on the nature of the project, organizational preferences, team size, project scope, and other factors. The ultimate goal is to produce high-quality software that meets user expectations while maintaining timelines and budgets.

