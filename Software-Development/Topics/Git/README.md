# Git

In this topic, we'll learn about the basics of Git and version control. We'll cover the importance of version control systems, the basics of Git, and the Git flow process.

- [Git](#git)
  - [Learning outcomes](#learning-outcomes)
  - [What is Git?](#what-is-git)
  - [Basic Git Architecture](#basic-git-architecture)
  - [Installing Git](#installing-git)
  - [Basic Git vocabulary](#basic-git-vocabulary)
  - [Basic Git Commands](#basic-git-commands)
  - [Graphical Git Clients](#graphical-git-clients)
    - [Some Popular Graphical Clients for Git:](#some-popular-graphical-clients-for-git)
    - [Reasons to Use Graphical Git Clients:](#reasons-to-use-graphical-git-clients)
  - [Git flow](#git-flow)
    - [1. **Main Branches**:](#1-main-branches)
    - [2. **Supporting Branches**:](#2-supporting-branches)
    - [**Basic Git Flow Process**:](#basic-git-flow-process)
  - [Git hosting platforms](#git-hosting-platforms)
  - [Excercises](#excercises)

## Learning outcomes

After completing this topic, you'll be able to:

- understand the importance of version control systems;
- describe the basics of Git and version control;
- describe the basic Git architecture;
- describe the basic Git vocabulary;
- describe the basic Git flow;

## What is Git?

```mermaid
    gitGraph
       commit id: "Create project"
       commit id: "Project base"
       branch nice_feature_branch
       checkout nice_feature_branch
       commit id: "Add frontend boilerplate"
       checkout nice_feature_branch
       commit id: "Connect frontend with API"
       checkout nice_feature_branch
       commit id: "Add frontend tests"
       checkout main
       merge nice_feature_branch id: "Basic frontend" tag: "Version 1.0"
       commit id: "Create documentation"
       checkout main
       commit id: "Update documentation"
```

**Git** is a distributed version control system (_DVCS_) used to track changes in source code during software development. It's designed to handle everything from small to very large projects with speed and efficiency. **Git** provides a way for multiple developers to collaborate on the same codebase without interfering with each other.

Git was created by Linus Torvalds in 2005 for the development of the Linux kernel. Its adoption has grown rapidly, and it's now the dominant version control system in the software industry. It's used by companies like Google, Facebook, Microsoft, and Twitter to manage their codebases.

Here are the key aspects and features of **Git**:

- **Distributed System**: Unlike centralized version control systems where there's a single central repository, in **Git**, every developer's copy of the code is also a repository that can contain the entire history and version tracking capabilities. This ensures redundancy and makes operations like branching and merging extremely efficient.
- **Branching and Merging**: **Git**'s branching model allows developers to create isolated branches for feature development or bug fixes. These branches can then be merged back into the main branch, typically known as the 'master' branch.
- **History**: **Git** tracks the entire history of the project. Every commit is checksummed and retrievable, ensuring integrity and traceability.
- **Staging Area**: **Git** introduces a unique concept of a _staging area_ or _index_. This is an intermediate area where commits can be formatted and reviewed before completing the commit.
- **Performance**: **Git** operations are performed locally, making it faster than many version control systems that rely on network operations.
- **Integrity**: **Git** uses a hashing algorithm called SHA-1 to checksum its data. This ensures the integrity of the version history.
- **Flexibility**: **Git** supports various workflows, from centralized to fully distributed, making it adaptable to different project needs.
- **Collaboration Platforms**: Platforms like _GitHub_, _GitLab_, and _Bitbucket_ enhance **Git**'s collaborative capabilities by providing code hosting, pull requests, code reviews, and issue tracking.
- **Free and Open Source**: **Git** is free software distributed under the terms of the GNU General Public License version 2.

## Basic Git Architecture

Git has a unique architecture and data model that makes it efficient and powerful. Here's a breakdown of the basic components of Git's architecture:

- **Blobs**:
  - Represents the content of a file in Git.
  - A blob holds the file data but doesnâ€™t contain any metadata about the file.
  - It's a binary large object and is identified by a SHA-1 hash of its content.
- **Trees**:
  - Represents a directory or folder in Git.
  - A tree object maps names to blobs or trees (essentially, it can reference other trees for subdirectories).
  - Like blobs, trees are identified by a SHA-1 hash.
- **Commits**:
  - Represents a particular point in the repository's history.
  - A commit points to a tree that captures the state of the repository at a certain point in time.
  - Contains metadata such as:
    - Author
    - Committer
    - Date
    - Commit message
  - Each commit also points to its parent commit(s), forming a linked list. This is what creates the "history" in Git. Merge commits can point to multiple parents.
  - Identified by a SHA-1 hash.
- **Branches**:
  - A moving pointer to a commit.
  - When you create a branch, Git creates a pointer to the commit you're currently on.
  - As new commits are created, the branch pointer automatically moves to point to the latest commit.
  - The default branch in most repositories is named "master" (though a shift towards naming it "main" has been observed recently).
  - Branches allow for divergent development, where features or experiments can be developed in isolation before merging them back into the main codebase.

This architecture, built around a directed acyclic graph of objects, is what allows Git to efficiently track changes, create branches, and merge histories. The use of SHA-1 hashes ensures the integrity and consistency of the repository across clones and versions.

## Installing Git

Latest version of Git and instructions for installation can be found from [git-scm.com](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git).

## Basic Git vocabulary

Git has its own unique vocabulary, and understanding these terms is key to working effectively with Git. Here's a basic overview of some essential Git terminology:
- **Repository (Repo)**:
  - A directory or storage space where your project lives. It contains all of the project files and the entire revision history.
  - Can be local (on your computer) or remote (e.g., on a server or service like GitHub).
- **Commit**:
  - A set of changes or modifications to files. Each commit is uniquely identified by a SHA-1 hash code.
  - Represents a snapshot of the repository's files and directory structure at a particular point in time.
- **Branch**:
  - A parallel version of a repository. It diverges from the main working project into a separate area where you can work without affecting the main or "master" branch.
  - Useful for developing new features or testing out ideas.
- **Master or main**:
  - The default development branch. Whenever you create a Git repository, a branch named "master" or "main" is created, and becomes the active branch.
  - Note: There's a shift in the industry to rename this default branch to "main" for inclusivity reasons.
- **Clone**:
  - A copy of a repository that lives on your computer instead of on a server elsewhere or the original repository site.
  - `git clone [URL]` is the command used to clone (or copy) a repository from an existing URL.
- **Fork**:
  - A personal copy of another user's repository. Forking is used to suggest changes to someone else's project or to use someone else's project as a starting point for your own idea.
- **Pull**:
  - Refers to when you fetch in changes from a remote repository or branch and merge them into your current branch.
  - `git pull [remote] [branch_name]` is the command used to pull changes.
- **Push**:
  - Sending your committed changes to a remote repository.
  - `git push [remote] [branch_name]` is the command used to push your changes.
- **HEAD**:
  - A special pointer or reference to a specific commit in the repository. By default, it points to the latest commit in the branch you're currently on.
- **Merge**:
  - The process of integrating changes from one branch into another.
- **Merge Conflict**:
  - Occurs when competing changes are made to the same line of a file, or when one person edits a file and another person deletes the same file.
  - Git will highlight the differences and require you to choose which changes to keep.
- **Pull Request (PR)**:
  - On platforms like GitHub, a pull request is a way to propose changes from a fork or a branch which can then be merged into another branch, typically the master/main branch.
- **Remote**:
  - A version of your project that is hosted on the internet or network somewhere. You can have multiple remotes, and they are handy for collaborating with others.
- **Staging Area (or Index)**:
  - An intermediate area where commits can be formatted and reviewed before completing the commit.
  - `git add [file_name]` is used to add changes to the staging area.
- **Fetch**:
  - The act of downloading new data from a remote repository. Unlike `pull`, `fetch` gets the data but does not merge it.
- **Tag**:
  - A reference or pointer to a specific commit, often used to capture a point in history that is significant, such as a release version.

This overview covers the basic terms you'll encounter when starting with Git. As you delve deeper, you'll naturally come across more advanced concepts and terms.

## Basic Git Commands

Here's a basic overview of some essential Git commands and their descriptions:

- **`git init`**:
  - Initializes a new Git repository and starts tracking an existing directory.
  - Adds a hidden subfolder within the existing directory that houses the internal data structure required for version control.
- **`git clone [url]`**:
  - Creates a local copy of a project that already exists remotely.
  - The clone includes all the projectâ€™s files, history, and branches.
- **`git add [file-name.txt]`**:
  - Adds changes in the file to the staging area.
  - Prepares and packages up changes for a commit.
- **`git add .`**:
  - Adds all the changes in the current directory to the staging area (useful for tracking several changes across different files).
- **`git commit -m "[commit message]"`**:
  - Captures a snapshot of the project's currently staged changes.
- **`git status`**:
  - Shows the status of changes as untracked, modified, or staged.
- **`git branch`**:
  - Lists all local branches in the repository.
  - If you need to see all branches (including remote), use `git branch -a`.
- **`git branch [branch-name]`**:
  - Creates a new branch.
- **`git checkout [branch-name]`**:
  - Switches to the specified branch and updates the working directory.
  - Note: The command has evolved. You can now use `git switch [branch-name]` in newer versions of Git.
- **`git merge [branch-name]`**:
  - Merges the specified branchâ€™s history into the current branch.
- **`git pull`**:
  - Updates your current local working branch with all new commits from the corresponding remote branch on GitHub.
- **`git push [remote-name] [branch-name]`**:
  - Pushes your local branch updates to the corresponding remote branch on GitHub.
- **`git log`**:
  - Displays an ordered list of all the commits which lead up to the current state of the branch.
  - There are many options to tailor the output format, like `git log --oneline` for a condensed view.
- **`git diff`**:
  - Shows the file differences that are not yet staged.
- **`git diff --staged`**:
  - Shows file differences when comparing the staged changes to the last commit.
- **`git remote add [alias] [url]`**:
  - Adds a remote repository to your local project.
- **`git remote -v`**:
  - Lists all remote repositories connected to the local project.
- **`git fetch`**:
  - Fetches all the updates from the remote repository (does not merge them).
- **`git revert [commit]`**:
  - Undoes all the changes made in a particular commit with a new commit.
- **`git reset`**:
  - Resets your staging area to match the most recent commit, but leaves the working directory unchanged. Useful for undoing `git add`.

This list covers the basics to get you started. Git is a deep tool with a variety of commands, and as you gain more experience, you'll discover many more advanced commands and options that can be used in various scenarios.

## Graphical Git Clients

**Graphical Git Clients** are applications that provide a visual interface to interact with Git, rather than relying solely on the command-line. They visually represent the version history, branches, and other aspects of a Git repository.

While graphical clients can be incredibly helpful, especially for those not comfortable with the command line, they do abstract away some of the intricacies of Git. For deeper, more complex operations, or to truly understand the inner workings of Git, familiarity with the command line is beneficial. Both approaches have their advantages, and many developers find a hybrid approach (using both command line and GUI) to be the most efficient.

### Some Popular Graphical Clients for Git:

- [**GitHub Desktop**](https://desktop.github.com/): This is the official GUI for GitHub. Itâ€™s open-source and cross-platform (available for macOS and Windows).
- [**Sourcetree**](https://www.sourcetreeapp.com/): Developed by Atlassian, it's a free tool available for macOS and Windows. It offers visual interaction with your repositories and supports Mercurial as well as Git.
- [**GitKraken**](https://www.gitkraken.com/): This cross-platform tool (available for Windows, macOS, and Linux) offers a vibrant and interactive interface. It's known for its graph visualization and has integrations with GitHub, GitLab, Bitbucket, and more.
- [**TortoiseGit**](https://tortoisegit.org/): Primarily for Windows, TortoiseGit integrates directly into the Windows shell, so you can right-click on a folder to access its features.

### Reasons to Use Graphical Git Clients:

- **User-Friendly**: For beginners, the command line can be intimidating. Graphical clients offer a more approachable and intuitive interface to interact with Git.
- **Visualization**: They provide a clear visual representation of branches, commits, merges, and more. This is especially helpful in understanding the flow and structure of commits in a repository.
- **Simplifies Complex Tasks**: Some Git tasks can be complex and verbose on the command line. GUI clients often simplify these processes into more manageable steps or provide a drag-and-drop interface.
- **Conflict Resolution**: Many graphical clients offer a visual way to resolve merge conflicts, making it clearer and sometimes easier than manually editing conflict markers in a text editor.
- **Integrated Tooling**: Graphical clients might come with built-in tools or integrations, such as Git blame, repository hosting services, and more.
- **Multitasking**: GUIs usually allow you to work on multiple repositories in separate tabs/windows, making context switching easier.
- **Immediate Feedback**: Many GUIs provide immediate visual feedback for most operations, such as the result of a merge or the changes introduced in a particular commit.
- **Support for Non-Git Operations**: Some GUIs offer features that aren't strictly Git operations, like the ability to open a file in a preferred editor, view the command history, or even run custom scripts.

## Git flow

Git Flow is a popular workflow methodology in Git that defines a structured approach to branching and merging. It provides a solid framework for managing larger projects and can simplify the process of collaborating with other developers on a shared repository. Below, I'll outline the Git Flow process, focusing on the role of branching:

### 1. **Main Branches**:

- **`main` (formerly `master`)**:
  - This branch contains the official release history.
  - All commits in the `main` branch represent a version of the software that is fully tested and deployable.
- **`develop`**:
  - Serves as an integration branch for features.
  - All the changes destined for the next release are integrated into this branch.

### 2. **Supporting Branches**:

These branches are used to aid parallel development, easily track features, prepare for releases, and quickly fix live issues.

- **Feature Branches**:
  - Branch off from: `develop`
  - Merge back into: `develop`
  - Naming convention: anything except `main`, `develop`, `release-*`, or `hotfix-*`
  - Purpose: Used to develop new features or enhancements. They exist as long as the feature is in development.

    ```mermaid
    graph LR
        A[develop] --> B[feature/feature_name]
        B --> A
    ```

- **Release Branches**:
  - Branch off from: `develop`
  - Merge back into: `main` and `develop`
  - Naming convention: `release-*`
  - Purpose: Used to prepare a new product version. This is where we tag our versions before they go into production. Bug fixes can be applied in this branch.

    ```mermaid
    graph LR
        A[develop] --> B[release/version_number]
        B --> C[main]
        B --> A
    ```

- **Hotfix Branches**:
  - Branch off from: `main`
  - Merge back into: `main` and `develop`
  - Naming convention: `hotfix-*`
  - Purpose: They arise from the necessity to act immediately upon an undesired state of the `main` branch. Used to quickly patch production releases.

    ```mermaid
    graph LR
        A[main] --> B[hotfix/issue]
        B --> A
        B --> C[develop]
    ```

### **Basic Git Flow Process**:

```mermaid
gitGraph
    commit id: "Create project"
    branch develop
    checkout develop
    commit id: "Project base"
    branch feature/nice_feature
    checkout feature/nice_feature
    commit id: "Add frontend boilerplate"
    commit id: "Connect frontend with API"
    commit id: "Add frontend tests"
    checkout develop
    merge feature/nice_feature
    branch release/1.0
    checkout release/1.0
    commit id: "Prepare for release"
    checkout main
    merge release/1.0 id: "Release Version 1.0" tag: "Version 1.0"
    checkout develop
    merge release/1.0
    checkout main
```

1. **Initialization**:
   Initialize a Git repository and then set up an empty `main` and `develop` branch.
2. **Start a New Feature**:
   For every new feature, create a new branch from `develop`, and name it according to the feature you're working on.
3. **Incorporate a Finished Feature**:
   Once the feature is complete and tested, it is merged back into `develop`. It awaits the next release cycle for integration into `main`.
4. **Release Time**:
   When enough features are ready, or a predetermined release point is reached, `develop` is branched off to a release branch, where final testing happens.
5. **Merge with Main**:
   Once the release branch is thoroughly tested, it is merged into `main` and tagged with a version number. It then also needs to be merged back into `develop` to ensure features added in the next cycle have the hotfixes and updates.
6. **Hotfixes**:
   If an issue is detected in the `main` branch and needs an immediate fix, a hotfix branch is created. Once the hotfix is complete, it's merged both into `main` (and tagged) and into `develop`.

Git Flow offers a rigorous framework for large-scale projects, but it might be overkill for smaller projects or teams. Some teams opt for simpler workflows, like GitHub flow or GitLab flow. Still, understanding Git Flow provides a solid foundation for how branching can be used in complex scenarios.

## Git hosting platforms

We could use Git locally, but it's more common to use a remote Git hosting platform. These platforms provide a centralized location for storing and collaborating on Git repositories. They also offer additional features like issue tracking, pull requests, code reviews, and more.

Here are some popular Git hosting platforms:

- [**GitHub**](https://github.com)
- [**GitLab**](https://gitlab.com)
- [**Bitbucket**](https://bitbucket.org)
- etc.

## Excercises

Try to explain the following concepts in your own words:
- What is Git and Version Control?
- Name at least four terms from the git vocabulary
- Name at least one Git hosting platform

Next steps:
- install `git` on your computer

# Git

Bu konuda, Git ve sÃ¼rÃ¼m kontrolÃ¼nÃ¼n temellerini Ã¶ÄŸreneceÄŸiz. SÃ¼rÃ¼m kontrol sistemlerinin Ã¶nemi, Gitâ€™in temelleri ve Git akÄ±ÅŸ sÃ¼reci hakkÄ±nda bilgi vereceÄŸiz.

- [Git](#git)
  - [Ã–ÄŸrenme Ã‡Ä±ktÄ±larÄ±](#Ã¶ÄŸrenme-Ã§Ä±ktÄ±larÄ±)
  - [Git Nedir?](#git-nedir)
  - [Temel Git Mimarisi](#temel-git-mimarisi)
  - [Git YÃ¼kleme](#git-yÃ¼kleme)
  - [Temel Git KavramlarÄ±](#temel-git-kavramlarÄ±)
  - [Temel Git KomutlarÄ±](#temel-git-komutlarÄ±)
  - [Grafiksel Git Ä°stemcileri](#grafiksel-git-istemcileri)
    - [Git Ä°Ã§in PopÃ¼ler Grafiksel Ä°stemciler:](#git-iÃ§in-popÃ¼ler-grafiksel-istemciler)
    - [Grafiksel Git Ä°stemcileri KullanmanÄ±n Nedenleri:](#grafiksel-git-istemcileri-kullanmanÄ±n-nedenleri)
  - [Git AkÄ±ÅŸÄ±](#git-akÄ±ÅŸÄ±)
    - [1. **Ana Dallar**:](#1-ana-dallar)
    - [2. **Destekleyici Dallar**:](#2-destekleyici-dallar)
    - [**Temel Git AkÄ±ÅŸ SÃ¼reci**:](#temel-git-akÄ±ÅŸ-sÃ¼reci)
  - [Git BarÄ±ndÄ±rma PlatformlarÄ±](#git-barÄ±ndÄ±rma-platformlarÄ±)
  - [AlÄ±ÅŸtÄ±rmalar](#alÄ±ÅŸtÄ±rmalar)

## Ã–ÄŸrenme Ã‡Ä±ktÄ±larÄ±

Bu konuyu tamamladÄ±ktan sonra ÅŸunlarÄ± yapabileceksiniz:

- SÃ¼rÃ¼m kontrol sistemlerinin Ã¶nemini anlayabileceksiniz;
- Git ve sÃ¼rÃ¼m kontrolÃ¼nÃ¼n temellerini aÃ§Ä±klayabileceksiniz;
- Temel Git mimarisini aÃ§Ä±klayabileceksiniz;
- Temel Git kavramlarÄ±nÄ± aÃ§Ä±klayabileceksiniz;
- Temel Git akÄ±ÅŸÄ±nÄ± aÃ§Ä±klayabileceksiniz;

## Git Nedir?

```mermaid
    gitGraph
       commit id: "Projeyi oluÅŸtur"
       commit id: "Proje temeli"
       branch nice_feature_branch
       checkout nice_feature_branch
       commit id: "Frontend iskeletini ekle"
       checkout nice_feature_branch
       commit id: "Frontend'i API ile baÄŸla"
       checkout nice_feature_branch
       commit id: "Frontend testlerini ekle"
       checkout main
       merge nice_feature_branch id: "Temel frontend" tag: "Versiyon 1.0"
       commit id: "DokÃ¼mantasyon oluÅŸtur"
       checkout main
       commit id: "DokÃ¼mantasyonu gÃ¼ncelle"

```

**Git**, yazÄ±lÄ±m geliÅŸtirme sÄ±rasÄ±nda kaynak kodundaki deÄŸiÅŸiklikleri izlemek iÃ§in kullanÄ±lan daÄŸÄ±lmÄ±ÅŸ bir versiyon kontrol sistemidir (_DVCS_). KÃ¼Ã§Ã¼kten Ã§ok bÃ¼yÃ¼k projelere kadar her ÅŸeyi hÄ±z ve verimlilikle yÃ¶netmek iÃ§in tasarlanmÄ±ÅŸtÄ±r. **Git**, birden fazla geliÅŸtiricinin aynÄ± kod tabanÄ± Ã¼zerinde birbirlerine mÃ¼dahale etmeden iÅŸbirliÄŸi yapmalarÄ±nÄ± saÄŸlar.

Git, 2005 yÄ±lÄ±nda Linux Ã§ekirdeÄŸinin geliÅŸtirilmesi iÃ§in Linus Torvalds tarafÄ±ndan yaratÄ±lmÄ±ÅŸtÄ±r. Benimsenmesi hÄ±zla artmÄ±ÅŸ ve ÅŸimdi yazÄ±lÄ±m endÃ¼strisindeki egemen versiyon kontrol sistemi haline gelmiÅŸtir. Google, Facebook, Microsoft ve Twitter gibi ÅŸirketler, kod tabanlarÄ±nÄ± yÃ¶netmek iÃ§in Git'i kullanmaktadÄ±r.

Ä°ÅŸte **Git**'in ana Ã¶zellikleri ve Ã¶zellikleri:

- **DaÄŸÄ±tÄ±k Sistem**: Tek bir merkezi depo bulunan merkezi versiyon kontrol sistemlerinin aksine, **Git**'te her geliÅŸtiricinin kod kopyasÄ±, tÃ¼m tarihÃ§e ve versiyon takibi Ã¶zelliklerini iÃ§erebilen bir depo olarak iÅŸlev gÃ¶rÃ¼r. Bu, yedekliliÄŸi garanti eder ve dallanma (branching) ve birleÅŸtirme (merging) iÅŸlemlerini son derece verimli hale getirir.
- **Dallanma ve BirleÅŸtirme**: **Git**'in dallanma modeli, geliÅŸtiricilerin Ã¶zellik geliÅŸtirme veya hata dÃ¼zeltmeleri iÃ§in izole dallar yaratmasÄ±na olanak tanÄ±r. Bu dallar daha sonra ana dal (genellikle 'master' dalÄ± olarak bilinir) ile birleÅŸtirilebilir.
- **GeÃ§miÅŸ**: **Git** proje geÃ§miÅŸinin tamamÄ±nÄ± takip eder. Her commit, kontrol edilen ve geri alÄ±nabilen bir Ã¶zet (checksum) iÃ§erir, bu da bÃ¼tÃ¼nlÃ¼k ve izlenebilirlik saÄŸlar.
- **AÅŸama AlanÄ± (Staging Area)**: **Git**, _aÅŸama alanÄ±_ veya _index_ adÄ± verilen benzersiz bir kavramÄ± tanÄ±tÄ±r. Bu, commit'lerin tamamlanmadan Ã¶nce biÃ§imlendirilebileceÄŸi ve gÃ¶zden geÃ§irilebileceÄŸi ara bir alandÄ±r.
- **Performans**: **Git** iÅŸlemleri yerel olarak gerÃ§ekleÅŸtirilir, bu da aÄŸ iÅŸlemlerine dayanan birÃ§ok versiyon kontrol sistemine kÄ±yasla daha hÄ±zlÄ± olmasÄ±nÄ± saÄŸlar.
- **BÃ¼tÃ¼nlÃ¼k**: **Git** verilerini kontrol etmek iÃ§in SHA-1 adÄ± verilen bir karma algoritmasÄ± kullanÄ±r. Bu, versiyon geÃ§miÅŸinin bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ garanti eder.
- **Esneklik**: **Git** Ã§eÅŸitli iÅŸ akÄ±ÅŸlarÄ±nÄ± destekler, merkezi sistemlerden tamamen daÄŸÄ±tÄ±k sistemlere kadar, bu da farklÄ± proje ihtiyaÃ§larÄ±na uyum saÄŸlamasÄ±nÄ± saÄŸlar.
- **Ä°ÅŸbirliÄŸi PlatformlarÄ±**: _GitHub_, _GitLab_ ve _Bitbucket_ gibi platformlar, **Git**'in iÅŸbirliÄŸi olanaklarÄ±nÄ± artÄ±rarak kod barÄ±ndÄ±rma, pull request'ler, kod incelemeleri ve hata izleme gibi hizmetler sunar.
- **Ãœcretsiz ve AÃ§Ä±k Kaynak**: **Git**, GNU Genel Kamu LisansÄ± sÃ¼rÃ¼m 2 altÄ±nda daÄŸÄ±tÄ±lan Ã¼cretsiz bir yazÄ±lÄ±mdÄ±r.

- ## Temel Git Mimarisi

Git, verimli ve gÃ¼Ã§lÃ¼ olmasÄ±nÄ± saÄŸlayan benzersiz bir mimariye ve veri modeline sahiptir. Ä°ÅŸte Git'in temel bileÅŸenlerinin bir aÃ§Ä±klamasÄ±:

- **Bloklar (Blobs)**:
  - Git'teki bir dosyanÄ±n iÃ§eriÄŸini temsil eder.
  - Bir blob, dosya verilerini tutar ancak dosya hakkÄ±nda herhangi bir meta veriye sahip deÄŸildir.
  - Bu, ikili bÃ¼yÃ¼k bir nesnedir ve iÃ§eriÄŸinin SHA-1 hashâ€™i ile tanÄ±mlanÄ±r.
- **AÄŸaÃ§lar (Trees)**:
  - Git'teki bir dizini veya klasÃ¶rÃ¼ temsil eder.
  - Bir aÄŸaÃ§ nesnesi, isimleri blob'lara veya diÄŸer aÄŸaÃ§lara (temelde alt dizinler iÃ§in baÅŸka aÄŸaÃ§lara) eÅŸler.
  - Blob'lar gibi, aÄŸaÃ§lar da bir SHA-1 hashâ€™i ile tanÄ±mlanÄ±r.
- **Commit'ler (Commits)**:
  - Depodaki belirli bir zamanÄ± temsil eder.
  - Bir commit, depo durumunu belirli bir zamanda yakalayan bir aÄŸaca iÅŸaret eder.
  - AÅŸaÄŸÄ±daki gibi meta veriler iÃ§erir:
    - Yazar
    - Commit yapan kiÅŸi
    - Tarih
    - Commit mesajÄ±
  - Her commit, aynÄ± zamanda ebeveyn commit'ine iÅŸaret eder, bÃ¶ylece baÄŸlÄ± bir liste oluÅŸturur. Bu, Git'teki "tarihÃ§eyi" yaratÄ±r. BirleÅŸtirme commit'leri, birden fazla ebeveyn commit'ine iÅŸaret edebilir.
  - SHA-1 hashâ€™i ile tanÄ±mlanÄ±r.
- **Dallar (Branches)**:
  - Bir commitâ€™e hareket eden bir iÅŸaretÃ§i.
  - Bir dal oluÅŸturduÄŸunuzda, Git, o anda bulunduÄŸunuz commit'e bir iÅŸaretÃ§i oluÅŸturur.
  - Yeni commit'ler oluÅŸturuldukÃ§a, dal iÅŸaretÃ§isi otomatik olarak en son commit'e iÅŸaret edecek ÅŸekilde hareket eder.
  - Ã‡oÄŸu depoda varsayÄ±lan dal "master" olarak adlandÄ±rÄ±lÄ±r (ancak son zamanlarda "main" olarak adlandÄ±rÄ±lmaya doÄŸru bir kayma gÃ¶zlemlenmiÅŸtir).
  - Dallar, Ã¶zellikler veya deneylerin ana kod tabanÄ±na birleÅŸtirilmeden Ã¶nce izole bir ÅŸekilde geliÅŸtirilebilmesi iÃ§in sapma geliÅŸtirmeye olanak tanÄ±r.

Bu mimari, yÃ¶nlendirilmiÅŸ asiklik bir grafik Ã¼zerine kurulu olup, Git'in deÄŸiÅŸiklikleri verimli bir ÅŸekilde takip etmesini, dallar oluÅŸturmasÄ±nÄ± ve tarihÃ§eleri birleÅŸtirmesini saÄŸlar. SHA-1 hashâ€™lerinin kullanÄ±mÄ±, depo bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ ve tutarlÄ±lÄ±ÄŸÄ±nÄ± kopyalar ve sÃ¼rÃ¼mler arasÄ±nda garanti eder.

## Git Kurulumu

Git'in en son sÃ¼rÃ¼mÃ¼ne ve kurulum talimatlarÄ±na [git-scm.com](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git) adresinden ulaÅŸabilirsiniz.

## Temel Git Terminolojisi

Git, kendine Ã¶zgÃ¼ bir terminolojiye sahiptir ve bu terimleri anlamak, Git ile etkili Ã§alÄ±ÅŸmanÄ±n anahtarÄ±dÄ±r. Ä°ÅŸte bazÄ± temel Git terimlerinin genel bir Ã¶zeti:

- **Depo (Repo)**:
  - Projenizin bulunduÄŸu dizin veya depolama alanÄ±dÄ±r. TÃ¼m proje dosyalarÄ±nÄ± ve tÃ¼m revizyon geÃ§miÅŸini iÃ§erir.
  - Yerel (bilgisayarÄ±nÄ±zda) veya uzak (Ã¶rneÄŸin, bir sunucuda veya GitHub gibi bir hizmette) olabilir.
- **Commit**:
  - Dosyalarda yapÄ±lan deÄŸiÅŸiklik veya dÃ¼zenlemeler setidir. Her commit, benzersiz bir SHA-1 hash kodu ile tanÄ±mlanÄ±r.
  - Depodaki dosyalarÄ±n ve dizin yapÄ±sÄ±nÄ±n belirli bir zaman dilimindeki anlÄ±k gÃ¶rÃ¼ntÃ¼sÃ¼nÃ¼ temsil eder.
- **Dal (Branch)**:
  - Depo iÃ§in paralel bir versiyonudur. Ana projeden ayrÄ±larak, ana veya "master" dalÄ±nÄ± etkilemeden Ã§alÄ±ÅŸabileceÄŸiniz ayrÄ± bir alana sapar.
  - Yeni Ã¶zellikler geliÅŸtirmek veya fikirleri test etmek iÃ§in kullanÄ±ÅŸlÄ±dÄ±r.
- **Master veya main**:
  - VarsayÄ±lan geliÅŸtirme dalÄ±dÄ±r. Bir Git deposu oluÅŸturduÄŸunuzda, "master" veya "main" adÄ±nda bir dal oluÅŸturulur ve bu dal aktif dal olur.
  - Not: Son zamanlarda, sektÃ¶rde bu varsayÄ±lan dalÄ±n adÄ±nÄ± kapsayÄ±cÄ±lÄ±k amaÃ§lÄ± olarak "main" olarak deÄŸiÅŸtirme eÄŸilimi vardÄ±r.
- **Clone (Klonlama)**:
  - Depodan bilgisayarÄ±nÄ±za kopyalanan bir reponun versiyonudur. Sunucuda veya baÅŸka bir yerdeki orijinal depo yerine bilgisayarÄ±nÄ±zda bulunur.
  - `git clone [URL]` komutu, mevcut bir URL'den bir depoyu klonlamak (veya kopyalamak) iÃ§in kullanÄ±lÄ±r.
- **Fork (Ã‡atal)**:
  - BaÅŸka bir kullanÄ±cÄ±nÄ±n deposunun kiÅŸisel kopyasÄ±dÄ±r. Fork, baÅŸkasÄ±nÄ±n projesine deÄŸiÅŸiklikler Ã¶nerirken veya baÅŸkasÄ±nÄ±n projesini kendi fikriniz iÃ§in baÅŸlangÄ±Ã§ noktasÄ± olarak kullanÄ±rken kullanÄ±lÄ±r.
- **Pull**:
  - Uzak bir depodan veya dalÄ±ndan deÄŸiÅŸiklikleri alÄ±p, mevcut dalÄ±nÄ±za birleÅŸtirmek anlamÄ±na gelir.
  - `git pull [remote] [branch_name]` komutu, deÄŸiÅŸiklikleri Ã§ekmek (pull) iÃ§in kullanÄ±lÄ±r.
- **Push (GÃ¶nderme)**:
  - YapÄ±lan commit'leri uzak bir depoya gÃ¶ndermek anlamÄ±na gelir.
  - `git push [remote] [branch_name]` komutu, deÄŸiÅŸikliklerinizi gÃ¶ndermek (push) iÃ§in kullanÄ±lÄ±r.
- **HEAD**:
  - Depodaki belirli bir commit'e iÅŸaret eden Ã¶zel bir iÅŸaretÃ§i veya referanstÄ±r. VarsayÄ±lan olarak, ÅŸu anda bulunduÄŸunuz dalda en son commit'e iÅŸaret eder.
- **Merge (BirleÅŸtirme)**:
  - Bir dalÄ±n deÄŸiÅŸikliklerini baÅŸka bir dala entegre etme sÃ¼recidir.
- **Merge Ã‡atÄ±ÅŸmasÄ± (Merge Conflict)**:
  - AynÄ± dosyanÄ±n aynÄ± satÄ±rÄ±nda Ã§eliÅŸkili deÄŸiÅŸiklikler yapÄ±ldÄ±ÄŸÄ±nda veya bir kiÅŸi bir dosyayÄ± dÃ¼zenlerken, baÅŸka bir kiÅŸi aynÄ± dosyayÄ± silerse Ã§atÄ±ÅŸma meydana gelir.
  - Git, farklarÄ± vurgular ve hangi deÄŸiÅŸikliklerin saklanacaÄŸÄ±na karar vermeniz iÃ§in sizi yÃ¶nlendirir.
- **Pull Request (PR)**:
  - GitHub gibi platformlarda, bir pull request, bir forktan veya bir daldan deÄŸiÅŸiklikler Ã¶nerme yoludur ve bu deÄŸiÅŸiklikler daha sonra baÅŸka bir dal ile birleÅŸtirilebilir, genellikle master/main dalÄ±na.
- **Remote (Uzak)**:
  - Projenizin internet veya aÄŸ Ã¼zerinde barÄ±ndÄ±rÄ±lan versiyonudur. Birden fazla uzak depo olabilir ve bunlar baÅŸkalarÄ±yla iÅŸbirliÄŸi yaparken kullanÄ±ÅŸlÄ±dÄ±r.
- **AÅŸama AlanÄ± (veya Index)**:
  - Commit'lerin tamamlanmadan Ã¶nce biÃ§imlendirilebileceÄŸi ve gÃ¶zden geÃ§irilebileceÄŸi ara bir alandÄ±r.
  - `git add [file_name]` komutu, deÄŸiÅŸiklikleri aÅŸama alanÄ±na eklemek iÃ§in kullanÄ±lÄ±r.
- **Fetch (Alma)**:
  - Uzak bir depodan yeni veriler indirme iÅŸlemidir. `pull` komutunun aksine, `fetch` veriyi alÄ±r ancak birleÅŸtirme yapmaz.
- **Tag (Etiket)**:
  - Belirli bir commit'e referans veya iÅŸaretÃ§idir, genellikle Ã¶nemli bir tarihsel noktayÄ±, Ã¶rneÄŸin bir sÃ¼rÃ¼mÃ¼n yayÄ±nlandÄ±ÄŸÄ± zamanÄ± iÅŸaretlemek iÃ§in kullanÄ±lÄ±r.

Bu genel bakÄ±ÅŸ, Git'e yeni baÅŸlayanlarÄ±n karÅŸÄ±laÅŸacaÄŸÄ± temel terimleri kapsamaktadÄ±r. Daha derine indikÃ§e, doÄŸal olarak daha ileri dÃ¼zey kavramlar ve terimler ile karÅŸÄ±laÅŸacaksÄ±nÄ±z.

## Temel Git KomutlarÄ±

Ä°ÅŸte bazÄ± temel Git komutlarÄ±nÄ±n ve aÃ§Ä±klamalarÄ±nÄ±n genel bir Ã¶zeti:

- **`git init`**:
  - Yeni bir Git deposu baÅŸlatÄ±r ve mevcut bir dizini izlemeye baÅŸlar.
  - Versiyon kontrolÃ¼ iÃ§in gerekli olan iÃ§ veri yapÄ±sÄ±nÄ± barÄ±ndÄ±ran gizli bir alt klasÃ¶r ekler.
- **`git clone [url]`**:
  - Zaten uzakta bulunan bir projenin yerel kopyasÄ±nÄ± oluÅŸturur.
  - Klon, projenin tÃ¼m dosyalarÄ±nÄ±, geÃ§miÅŸini ve dallarÄ±nÄ± iÃ§erir.
- **`git add [file-name.txt]`**:
  - Dosyadaki deÄŸiÅŸiklikleri aÅŸama alanÄ±na ekler.
  - DeÄŸiÅŸiklikleri commit iÃ§in hazÄ±rlar ve paketler.
- **`git add .`**:
  - GeÃ§erli dizindeki tÃ¼m deÄŸiÅŸiklikleri aÅŸama alanÄ±na ekler (farklÄ± dosyalarda yapÄ±lan birkaÃ§ deÄŸiÅŸikliÄŸi takip etmek iÃ§in kullanÄ±ÅŸlÄ±dÄ±r).
- **`git commit -m "[commit mesajÄ±]"`**:
  - Projenin ÅŸu anki aÅŸama alanÄ±ndaki deÄŸiÅŸikliklerinin bir anlÄ±k gÃ¶rÃ¼ntÃ¼sÃ¼nÃ¼ alÄ±r.
- **`git status`**:
  - DeÄŸiÅŸikliklerin durumunu izlenmeyen, deÄŸiÅŸtirilmiÅŸ veya aÅŸamaya alÄ±nmÄ±ÅŸ olarak gÃ¶sterir.
- **`git branch`**:
  - Depodaki tÃ¼m yerel dallarÄ± listeler.
  - TÃ¼m dallarÄ± (uzak dahil) gÃ¶rmek iÃ§in `git branch -a` komutunu kullanÄ±n.
- **`git branch [branch-name]`**:
  - Yeni bir dal oluÅŸturur.
- **`git checkout [branch-name]`**:
  - Belirtilen dala geÃ§er ve Ã§alÄ±ÅŸma dizinini gÃ¼nceller.
  - Not: Bu komut evrimleÅŸti. Yeni Git sÃ¼rÃ¼mlerinde `git switch [branch-name]` komutunu kullanabilirsiniz.
- **`git merge [branch-name]`**:
  - Belirtilen dalÄ±n geÃ§miÅŸini, geÃ§erli dalÄ±nÄ±za birleÅŸtirir.
- **`git pull`**:
  - GeÃ§erli yerel Ã§alÄ±ÅŸma dalÄ±nÄ±zÄ±, GitHub'daki ilgili uzak dal ile tÃ¼m yeni commit'lerle gÃ¼nceller.
- **`git push [remote-name] [branch-name]`**:
  - Yerel dal gÃ¼ncellemelerinizi GitHub'daki ilgili uzak dalÄ±na gÃ¶nderir.
- **`git log`**:
  - DalÄ±n mevcut durumuna kadar yapÄ±lan tÃ¼m commit'lerin sÄ±ralÄ± listesini gÃ¶sterir.
  - Ã‡Ä±ktÄ± formatÄ±nÄ± Ã¶zelleÅŸtirmek iÃ§in birÃ§ok seÃ§enek vardÄ±r, Ã¶rneÄŸin `git log --oneline` komutu daha sÄ±kÄ±ÅŸtÄ±rÄ±lmÄ±ÅŸ bir gÃ¶rÃ¼nÃ¼m saÄŸlar.
- **`git diff`**:
  - HenÃ¼z aÅŸamaya alÄ±nmamÄ±ÅŸ dosya farklarÄ±nÄ± gÃ¶sterir.
- **`git diff --staged`**:
  - AÅŸamaya alÄ±nmÄ±ÅŸ deÄŸiÅŸikliklerin son commit ile karÅŸÄ±laÅŸtÄ±rÄ±lmasÄ±nÄ± gÃ¶sterir.
- **`git remote add [alias] [url]`**:
  - Yerel projeye bir uzak depo ekler.
- **`git remote -v`**:
  - Yerel projeye baÄŸlÄ± tÃ¼m uzak depolarÄ± listeler.
- **`git fetch`**:
  - Uzak depodan tÃ¼m gÃ¼ncellemeleri alÄ±r (birleÅŸtirme yapmaz).
- **`git revert [commit]`**:
  - Belirli bir commit'te yapÄ±lan tÃ¼m deÄŸiÅŸiklikleri yeni bir commit ile geri alÄ±r.
- **`git reset`**:
  - AÅŸama alanÄ±nÄ± en son commit ile eÅŸleÅŸecek ÅŸekilde sÄ±fÄ±rlar, ancak Ã§alÄ±ÅŸma dizinini deÄŸiÅŸtirmez. `git add` komutunu geri almak iÃ§in kullanÄ±ÅŸlÄ±dÄ±r.

Bu liste, baÅŸlamanÄ±z iÃ§in gerekli temel komutlarÄ± kapsar. Git, Ã§ok Ã§eÅŸitli komutlara sahip derin bir araÃ§tÄ±r ve deneyim kazandÄ±kÃ§a farklÄ± senaryolarda kullanÄ±labilecek daha ileri dÃ¼zey komutlar ve seÃ§enekler keÅŸfedeceksiniz.

## Grafiksel Git Ä°stemcileri

**Grafiksel Git Ä°stemcileri**, Git ile etkileÅŸimde bulunmak iÃ§in komut satÄ±rÄ±na dayanmak yerine gÃ¶rsel bir arayÃ¼z saÄŸlayan uygulamalardÄ±r. Versiyon geÃ§miÅŸini, dallarÄ± ve bir Git deposunun diÄŸer yÃ¶nlerini gÃ¶rsel olarak temsil ederler.

Grafiksel istemciler son derece yardÄ±mcÄ± olabilir, Ã¶zellikle komut satÄ±rÄ±ndan rahatsÄ±z olmayanlar iÃ§in, ancak Git'in bazÄ± inceliklerini soyutlarlar. Daha derin ve karmaÅŸÄ±k iÅŸlemler iÃ§in veya Git'in iÃ§ iÅŸleyiÅŸini tam olarak anlamak iÃ§in komut satÄ±rÄ±yla aÅŸina olmak faydalÄ±dÄ±r. Her iki yaklaÅŸÄ±mÄ±n da avantajlarÄ± vardÄ±r ve birÃ§ok geliÅŸtirici, her iki yÃ¶ntemi bir arada kullanmanÄ±n (komut satÄ±rÄ± ve GUI) en

### Grafiksel Git Ä°stemcilerini Kullanma Nedenleri:

- **KullanÄ±cÄ± Dostu**: BaÅŸlangÄ±Ã§ seviyesindeki kullanÄ±cÄ±lar iÃ§in komut satÄ±rÄ± korkutucu olabilir. Grafiksel istemciler, Git ile etkileÅŸim kurmak iÃ§in daha eriÅŸilebilir ve sezgisel bir arayÃ¼z sunar.
- **GÃ¶rselleÅŸtirme**: DallarÄ±, commit'leri, birleÅŸtirmeleri ve daha fazlasÄ±nÄ± net bir ÅŸekilde gÃ¶rsel olarak temsil ederler. Bu, bir deponun commit akÄ±ÅŸÄ±nÄ± ve yapÄ±sÄ±nÄ± anlamada Ã¶zellikle faydalÄ±dÄ±r.
- **KarmaÅŸÄ±k GÃ¶revleri BasitleÅŸtirir**: BazÄ± Git gÃ¶revleri komut satÄ±rÄ±nda karmaÅŸÄ±k ve uzun olabilir. GUI istemcileri bu iÅŸlemleri daha yÃ¶netilebilir adÄ±mlara indirger veya sÃ¼rÃ¼kle-bÄ±rak arayÃ¼zÃ¼ saÄŸlar.
- **Ã‡atÄ±ÅŸma Ã‡Ã¶zÃ¼mÃ¼**: BirÃ§ok grafiksel istemci, birleÅŸtirme Ã§atÄ±ÅŸmalarÄ±nÄ± Ã§Ã¶zmek iÃ§in gÃ¶rsel bir yol sunar, bu da metin dÃ¼zenleyicilerindeki Ã§atÄ±ÅŸma iÅŸaretÃ§ilerini manuel olarak dÃ¼zenlemekten bazen daha kolay ve daha anlaÅŸÄ±lÄ±r olabilir.
- **Entegre AraÃ§lar**: Grafiksel istemciler, Git blame, depo barÄ±ndÄ±rma hizmetleri gibi yerleÅŸik araÃ§lar veya entegrasyonlarla birlikte gelebilir.
- **Ã‡oklu GÃ¶rev DesteÄŸi**: GUI'ler genellikle birden fazla depo Ã¼zerinde ayrÄ± sekmeler/pencerelerle Ã§alÄ±ÅŸmanÄ±za olanak tanÄ±r, bu da baÄŸlam deÄŸiÅŸtirmeyi daha kolay hale getirir.
- **AnÄ±nda Geri Bildirim**: BirÃ§ok GUI, birleÅŸtirme sonucu veya belirli bir commit'te yapÄ±lan deÄŸiÅŸiklikler gibi Ã§oÄŸu iÅŸlem iÃ§in anÄ±nda gÃ¶rsel geri bildirim saÄŸlar.
- **Git DÄ±ÅŸÄ± OperasyonlarÄ± Destekler**: BazÄ± GUI'ler, bir dosyayÄ± tercih edilen editÃ¶rde aÃ§ma, komut geÃ§miÅŸini gÃ¶rÃ¼ntÃ¼leme veya Ã¶zel betikler Ã§alÄ±ÅŸtÄ±rma gibi Git iÅŸlemleri dÄ±ÅŸÄ±ndaki Ã¶zellikler sunar.

## Git AkÄ±ÅŸÄ±

Git AkÄ±ÅŸÄ±, Gitâ€™te popÃ¼ler bir iÅŸ akÄ±ÅŸÄ± metodolojisidir ve dallanma ve birleÅŸtirme iÃ§in yapÄ±landÄ±rÄ±lmÄ±ÅŸ bir yaklaÅŸÄ±m tanÄ±mlar. BÃ¼yÃ¼k projeleri yÃ¶netmek iÃ§in saÄŸlam bir Ã§erÃ§eve saÄŸlar ve baÅŸka geliÅŸtiricilerle ortak bir depoda iÅŸ birliÄŸi yapmayÄ± basitleÅŸtirebilir. AÅŸaÄŸÄ±da, Git AkÄ±ÅŸÄ± sÃ¼recini, Ã¶zellikle dal kullanÄ±mÄ± aÃ§Ä±sÄ±ndan Ã¶zetleyeceÄŸim:

### 1. **Ana Dallar**:

- **`main` (eski adÄ±yla `master`)**:
  - Bu dal, resmi sÃ¼rÃ¼m geÃ§miÅŸini iÃ§erir.
  - `main` dalÄ±ndaki tÃ¼m commit'ler, tamamen test edilmiÅŸ ve daÄŸÄ±tÄ±ma hazÄ±r bir yazÄ±lÄ±m sÃ¼rÃ¼mÃ¼nÃ¼ temsil eder.
- **`develop`**:
  - Ã–zellikler iÃ§in birleÅŸtirme dalÄ± olarak hizmet eder.
  - Bir sonraki sÃ¼rÃ¼m iÃ§in yapÄ±lacak tÃ¼m deÄŸiÅŸiklikler bu dala entegrasyon edilir.

### 2. **Destekleyici Dallar**:

Bu dallar, paralel geliÅŸtirmeyi desteklemek, Ã¶zellikleri kolayca takip etmek, sÃ¼rÃ¼me hazÄ±rlÄ±k yapmak ve canlÄ± sorunlarÄ± hÄ±zlÄ±ca Ã§Ã¶zmek iÃ§in kullanÄ±lÄ±r.

- **Ã–zellik DallarÄ±**:
  - Åžuradan dalar: `develop`
  - Geri birleÅŸtirilir: `develop`
  - Ä°simlendirme kuralÄ±: `main`, `develop`, `release-*` veya `hotfix-*` dÄ±ÅŸÄ±nda herhangi bir ÅŸey.
  - AmaÃ§: Yeni Ã¶zellikler veya iyileÅŸtirmeler geliÅŸtirmek iÃ§in kullanÄ±lÄ±r. Ã–zellik geliÅŸtirilene kadar var olurlar.

    ```mermaid
    graph LR
        A[develop] --> B[feature/feature_name]
        B --> A
    ```

- **SÃ¼rÃ¼m DallarÄ±**:
  - Åžuradan dalar: `develop`
  - Geri birleÅŸtirilir: `main` ve `develop`
  - Ä°simlendirme kuralÄ±: `release-*`
  - AmaÃ§: Yeni bir Ã¼rÃ¼n sÃ¼rÃ¼mÃ¼ hazÄ±rlamak iÃ§in kullanÄ±lÄ±r. Bu dalda sÃ¼rÃ¼mler etiketlenir ve Ã¼retime gitmeden Ã¶nce hata dÃ¼zeltmeleri yapÄ±labilir.

    ```mermaid
    graph LR
        A[develop] --> B[release/version_number]
        B --> C[main]
        B --> A
    ```

- **Hotfix DallarÄ±**:
  - Åžuradan dalar: `main`
  - Geri birleÅŸtirilir: `main` ve `develop`
  - Ä°simlendirme kuralÄ±: `hotfix-*`
  - AmaÃ§: `main` dalÄ±ndaki istenmeyen bir duruma hemen mÃ¼dahale edilmesi gerektiÄŸinde ortaya Ã§Ä±kar. Ãœretim sÃ¼rÃ¼mlerini hÄ±zla yama yapmak iÃ§in kullanÄ±lÄ±r.

    ```mermaid
    graph LR
        A[main] --> B[hotfix/issue]
        B --> A
        B --> C[develop]
    ```

### **Temel Git AkÄ±ÅŸÄ± SÃ¼reci**:

```mermaid
gitGraph
    commit id: "Proje oluÅŸturuldu"
    branch develop
    checkout develop
    commit id: "Proje tabanÄ±"
    branch feature/nice_feature
    checkout feature/nice_feature
    commit id: "Frontend iskeleti eklendi"
    commit id: "Frontend API ile baÄŸlantÄ± kuruldu"
    commit id: "Frontend testleri eklendi"
    checkout develop
    merge feature/nice_feature
    branch release/1.0
    checkout release/1.0
    commit id: "SÃ¼rÃ¼me hazÄ±rlanÄ±yor"
    checkout main
    merge release/1.0 id: "SÃ¼rÃ¼m 1.0 YayÄ±nlandÄ±" tag: "SÃ¼rÃ¼m 1.0"
    checkout develop
    merge release/1.0
    checkout main

```

1. **BaÅŸlatma**:
   Bir Git deposu baÅŸlatÄ±n ve ardÄ±ndan boÅŸ bir `main` ve `develop` dalÄ± oluÅŸturun.
2. **Yeni Bir Ã–zellik BaÅŸlatma**:
   Her yeni Ã¶zellik iÃ§in, `develop` dalÄ±ndan yeni bir dal oluÅŸturun ve Ã¼zerinde Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ±z Ã¶zelliÄŸe gÃ¶re adlandÄ±rÄ±n.
3. **Tamamlanan Ã–zelliÄŸi Dahil Etme**:
   Ã–zellik tamamlandÄ±ÄŸÄ±nda ve test edildiÄŸinde, geri `develop` dalÄ±na birleÅŸtirilir. Bir sonraki sÃ¼rÃ¼m dÃ¶ngÃ¼sÃ¼ iÃ§in `main` dalÄ±na entegrasyon bekler.
4. **SÃ¼rÃ¼m ZamanÄ±**:
   Yeterince Ã¶zellik hazÄ±r olduÄŸunda veya Ã¶nceden belirlenmiÅŸ bir sÃ¼rÃ¼m noktasÄ± ulaÅŸÄ±ldÄ±ÄŸÄ±nda, `develop` dalÄ± bir sÃ¼rÃ¼m dalÄ±na ayrÄ±lÄ±r ve burada son testler yapÄ±lÄ±r.
5. **Main ile BirleÅŸtirme**:
   SÃ¼rÃ¼m dalÄ± yeterince test edildikten sonra, `main` dalÄ±na birleÅŸtirilir ve bir sÃ¼rÃ¼m numarasÄ± ile etiketlenir. Daha sonra, gelecek dÃ¶ngÃ¼deki Ã¶zelliklerin hotfix'ler ve gÃ¼ncellemelerle uyumlu olmasÄ±nÄ± saÄŸlamak iÃ§in tekrar `develop` dalÄ±na birleÅŸtirilmesi gerekir.
6. **Hotfix'ler**:
   EÄŸer `main` dalÄ±nda bir sorun tespit edilirse ve hemen bir dÃ¼zeltme yapÄ±lmasÄ± gerekirse, bir hotfix dalÄ± oluÅŸturulur. Hotfix tamamlandÄ±ÄŸÄ±nda, hem `main` dalÄ±na (etiketlenmiÅŸ olarak) hem de `develop` dalÄ±na birleÅŸtirilir.

Git Flow, bÃ¼yÃ¼k Ã¶lÃ§ekli projeler iÃ§in katÄ± bir Ã§erÃ§eve sunar, ancak kÃ¼Ã§Ã¼k projeler veya ekipler iÃ§in fazla karmaÅŸÄ±k olabilir. BazÄ± ekipler, GitHub Flow veya GitLab Flow gibi daha basit iÅŸ akÄ±ÅŸlarÄ±nÄ± tercih edebilir. Yine de Git Flow'u anlamak, karmaÅŸÄ±k senaryolarda dallanmanÄ±n nasÄ±l kullanÄ±lacaÄŸÄ± konusunda saÄŸlam bir temel saÄŸlar.

## Git Hosting PlatformlarÄ±

Git'i yerel olarak kullanabiliriz, ancak daha yaygÄ±n olarak bir uzaktan Git hosting platformu kullanÄ±lÄ±r. Bu platformlar, Git depolarÄ±nÄ± saklamak ve Ã¼zerinde iÅŸ birliÄŸi yapmak iÃ§in merkezi bir yer saÄŸlar. AyrÄ±ca, hata izleme, pull request'ler, kod incelemeleri ve daha fazlasÄ± gibi ek Ã¶zellikler sunar.

Ä°ÅŸte bazÄ± popÃ¼ler Git hosting platformlarÄ±:

- [**GitHub**](https://github.com)
- [**GitLab**](https://gitlab.com)
- [**Bitbucket**](https://bitbucket.org)
- vb.

## AlÄ±ÅŸtÄ±rmalar

AÅŸaÄŸÄ±daki kavramlarÄ± kendi kelimelerinizle aÃ§Ä±klamayÄ± deneyin:
- Git ve SÃ¼rÃ¼m KontrolÃ¼ nedir?
- Git terimlerinden en az dÃ¶rt tanesini sayÄ±n.
- En az bir Git hosting platformu ismi sayÄ±n.

Sonraki adÄ±mlar:
- BilgisayarÄ±nÄ±za `git` yÃ¼kleyin
